---
title: 绘图配置
date: 2022-10-25 09:18:14
toc: true
tags: visualization
categories:
  - python
---

## 导入相关库

```python
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.mathtext import _mathtext as mathtext
from matplotlib.pyplot import MultipleLocator
mathtext.FontConstantsBase.sup1 = 0.5
mathtext.FontConstantsBase.sub1 = 0.3
mathtext.FontConstantsBase.sub2 = 0.3
import warnings
warnings.filterwarnings("ignore")
import matplotlib as mpl
mpl.rcParams['axes.prop_cycle'] = mpl.cycler(color = ["#0073C2FF","#EFC000FF","#868686FF","#CD534CFF","7AA6DCFF","#003C67FF","#8F7700FF","#3B3B3BFF","#A73030FF"])

config = {
    "font.family": 'sans-serif',
    "font.sans-serif": ["Arial"],
    "font.size": 8,
    "pdf.fonttype" : 42,
    "mathtext.fontset": "custom",
    'mathtext.rm' : 'Arial',
    'mathtext.it' : 'Arial:italic',
    'mathtext.bf' : 'Arial:bold',
    
    "mathtext.default": "rm",
    "font.weight": 'normal',
    "axes.labelweight": 'normal',
    
    'xtick.direction': 'in',
    'xtick.major.size':  2,
    'xtick.major.width': 1,
    'xtick.minor.size':  1,
    'xtick.minor.width': 1,
    'xtick.major.pad':   2,
    
    'ytick.direction': 'in',
    'ytick.major.size':  2,
    'ytick.major.width': 1,
    'ytick.minor.size':  1,
    'ytick.minor.width': 1,
    'ytick.major.pad':   2,
}
plt.rcParams.update(config)

```

## 计算统计参数

```python
def evaluation(obs,sim):
    '''
    sim: prediction,  n-D np.array
    obs: observation, n-D np.array
    Assume the first dimension is time, deal with time dimension
    NOTE: users should set cut off value for MNB and MNE:
    As for O3 1h and 8h evaluation:
    [ozone] > 40 or 60 ppb is suggested by EPA, but 30 ppb is used in J.L. Hu (2016)
    '''
    N = obs.shape[0]
    # mean observation
    mo = np.nanmean(obs,axis=0)
    # mean prediction
    mp = np.nanmean(sim,axis=0)
    
    error = sim - obs
    # bias error (B) / mean bias (MB) / Bias
    bias = np.nansum(error,axis=0)/N
    
    # Gross Error (E/GE) / Mean Absolute Error (MAE) / Mean Error (ME)
    ME = np.nansum(np.abs(error),axis=0)/N
    
    # Mean Normalized Bias (MNB) | range(-100% to +++) | NOTE What happend if obs .eq. zero???
    MNB = np.nansum(error/obs,axis=0)/N
    
    # Mean Normalized Error (MNE) | range(0 to +++) | NOTE What happend if obs .eq. zero???
    MNE = np.nansum(np.abs(error/obs),axis=0)/N 
    
    # Mean Fractional Bias (MFB) | range(-200% to +200%) | NOTE What happend if (obs+sim) .eq. zero???
    MFB = np.nansum(error/(sim+obs)*2.,axis=0)/N
    
    # Mean Fractional Error (MFE) | range(0 to +200%) | NOTE What happend if (obs+sim) .eq. zero???
    MFE = np.nansum(np.abs(error)/(sim+obs)*2.,axis=0)/N
    
    # Normalized Mean Bias (NMB) | range(-100% to +++) 
    NMB = np.nansum(error,axis=0)/np.nansum(obs,axis=0)
    
    # Normalized Mean Error (NME) | range(0 to +++) |
    NME = np.nansum(np.abs(error),axis=0)/np.nansum(obs,axis=0)
    
    # Root Mean Square Error (RMSE)
    RMSE = np.sqrt(np.nansum(np.square(error),axis=0)/N)
    
    # correlation coefficient (R)
    coef = ma.corrcoef(ma.masked_invalid(obs), ma.masked_invalid(sim)); R = coef[0,1]
    
    # Index of Agreement (IoA)
    IoA = 1 - np.nansum(np.square(error),axis=0)/np.nansum(np.square(np.abs(sim-mo)+np.abs(obs-mo)),axis=0)

    return mo,mp,bias,ME,MNB,MNE,MFB,MFE,NMB,NME,RMSE,R,IoA
```